# 控制器文档

## 介绍

`Sweet UI` 框架是一个模块化、自动化，且基于`webpack`工具的一种前端开发框架。
由于后台系统错综复杂，而`Sweet UI`是一种单页面应用型框架，具有自定义路由，前后端分离等特点，在资源引入等问题上采取了`webpack`的`require.ensure`的特性，利用`director.js`来执行js，所以就衍生了控制器概念，`控制器`是一个js对象，里面包含了内部方法以及开发者自定义的方法，通过`module.exports`托管给`Sweet UI`，并进行解析。当当前的浏览器url匹配了路由规则，则会去引入对应的控制器模块，所有在控制器引入的模块一起被打包，这就大大减少了单页面引入资源的损耗，真正做到`按需加载`。

## 示例

```
var demoController = {
    // 容器ID
    el: "#demoPage",
    //该控制器是否需要判断登录验证，1:不需要，0:需要 默认为0
    noCheckLogin:1,
    //页面样式类名
    className: ["demoPage"],
    // 页面渲染之前执行
    beforeRender: function() {
        //返回true则渲染，返回false则不渲染
        return true;
    },
    // 页面渲染
    renderer: {
        // #sweetRoot 为最顶层。可设置成其他容器，如#frameMain
        container: '#sweetRoot',
        // flase 为替换模式，true为追加模式
        mode: false,
        // 是否启用ajax模式   
        isAjax: false,
        // 开启ajax模式时，所需的jquery ajax 参数
        ajaxParams: {
            url: "",
        },
        responseHandler:function(data){
        	return data;
        },
        // 静态初始数据
        data: {},
        // html模板
        template: require('./index.html')
    },
    init: function () {
        //控制器主入口，所有需要执行的方法都要放到这里
        this.hanlder.init();
    },
    hanlder:{
        init:function(){

        }
    }
}
module.exports = demoController;
```

## 属性与方法

### 页面容器ID

在控制器对象的`el`属性可以设置其页面容器的id名.

### 控制器类型

在控制器对象的`type`属性可以设置页面容器的类型，设置为`container`表示无论如何会执行该控制器，默认不是当前页面不执行。

例如：

```
//路由规则配置
"/main":{
	on:"frame_index",
	"/mypage":"mypage_index"
}
```
当url访问`#/main/mypage` 时，在不设置控制器`frame`的`type`属性时的控制器执行情况，用`console.log`打印出结果。

```
执行了控制器 mypage
```

**只执行了控制器mypage，并不会执行frame**

如若设置控制器`frame`的`type`为`container`时

```
执行了控制器 frame
执行了控制器 mypage
```

设置了`type`后，无论如何都会执行该控制器，只要匹配了路由规则。

**每个路由匹配规则的最后一个匹配的控制器都会被执行，`type`属性无效**

**故此，外框类控制器都需要设置`type`属性为`container`，Sweet框架默认的`frame`和`pageMenu`外框类控制器就设置了该属性值**

### 页面访问权限

在控制器对象的`noCheckLogin `属性可以设置其页面的访问权限.
设置为`1`或者`true`时，则表示权限最大，不需要登录也能访问。否则会去判断是否登录，没有登录或者登录验证不通过则访问不了。

### 页面容器样式类名

在控制器对象的`className `属性可以设置其页面容器的样式类名.

### 页面事件委托器

在控制器对象的`eventListener`属性可以设置其页面的事件委托，例如

```
...
//事件监听器
eventListener: {
    'click .nav-switch': eventsHandler.toggleExpandMenu,
    'click #tanentChoseUl li a': eventsHandler.changeUser,
    'click #logout': eventsHandler.logoutSystem
},
...
```
```
'[events] [selectors]':[fn]
```

`events`为元素的触发事件的类型，比如`click`。

`selectors`为元素的选择器，比如 `ul li`。

`fn`为触发事件，比如

```
function(events){
	//方法体
	....
}
```

其写法和Jquery的`on`方法一致.

**注意这里的元素只能是在该页面容器下的，如果超出该页面容器的范围，那么监听无效。在`fn`中的`events`参数里除了继承了`jquery`，其中`events.data.controller`则是获取当前控制器的对象，以便调用。**

### 控制器生命周期

1.`beforeRender`：页面渲染前执行，根据函数返回结果执行下一步，`true`:则表示渲染，`false`:则表示不渲染

2.`renderer`:页面渲染配置项.

`container `:承载该页面容器的父容器ID

&nbsp; &nbsp; &nbsp; &nbsp; 默认有三种：

&nbsp; &nbsp; &nbsp; &nbsp; `#frame-pageMenu-main（附属菜单外框容器）`

&nbsp; &nbsp; &nbsp; &nbsp; `#frameMain(frame主框容器)`

&nbsp; &nbsp; &nbsp; &nbsp; `#sweetRoot(最外层容器)`

`mode`:将该页面渲染的html结果插入dom结构树中的方式，`false`为替换模式,`true`为追加模式

`isAjax`:表示是否开启ajax模式。`true`为开启，`false`为关闭.

`ajaxParams`:当开启了ajax模式后，该项生效，该项为所需的jquery ajax 参数

`responseHandler`:当开启了ajax模式后，该函数可以处理请求返回后的数据，并且返回给控制器本身。

`data`:手动设置的该页面渲染的初始数据

`template`:该页面的视图文件，必须用`require`方式引入。

3.`init`:该函数为控制器的主入口,也就是页面渲染后执行，所有需要执行的方法都放到这里，由于控制器对象都存在缓存，故此需要在init初始化一些页面`全局变量`

4.在最后需要把整个控制器对象托管给`sweet`。比如：

```
module.exports = demoController;
```

**这样就结束了整个控制器的生命周期**


### 控制器page属性

1、在访问控制器对象的`page`属性的`query`属性可以获取页面相关的参数。如：

```
//路由配置
...
"/main/demo/:id/:type":"demo_index"
...
```
```
//demo_index控制器
var demo={
	...
	init:function(){
		//参数id
		this.page.query[0]
		//参数type
		this.page.query[1]
	}
	...
}
```

当访问`#/main/demo/1/2`，并且执行了以上所述的控制器时，那么我们可以拿到参数id为1，参数type为2。

2、在访问控制器对象的`page`属性的`data`属性可以获取通过`特殊方式`渲染的页面数据源。如：
```
//demo_index控制器
var demo={
	...
	// 页面渲染
    renderer: {
        // #sweetRoot 为最顶层。可设置成其他容器，如#frameMain
        container: '#sweetRoot',
        // flase 为替换模式，true为追加模式
        mode: false,
        // 是否启用ajax模式   
        isAjax: true,
        // 开启ajax模式时，所需的jquery ajax 参数
        ajaxParams: {
            url: "/platform/session-info"
        },
        responseHandler:function(data){
        	return data;
        },
        // 手动设置初始数据
        data: {},
        // html模板
        template: require('./index.html')
    },
	init:function(){
		//页面数据源
		this.page.data
	}
	...
}
```
当控制器配置如上，则访问demo时,`this.page.data`可以获取到开启了`ajax`模式并且经过了`responseHandler`处理过后的`/platform/session-info`请求接口返回的数据和控制器渲染对象的`data`对象的一个深度合并的数据集。

**根据上述特性，可以将一个父容器的控制器对象赋值给window对象，来实现全局变量的效果。那么所有的子控制器都能够获取父容器的控制器的`page.data`对象了**

### 控制器renderer.refresh方法

在开启了控制器`ajax`模式时，可以调用此方法，根据业务的需要，调用该方法可以局部刷新整个页面的逻辑。

### 控制器renderer.refreshByData($data)

在开启了控制器`ajax`模式时，可以调用此方法，该方法与`refresh`相同，区别在于多了一个数据，可以将该数据和现有的控制器`$ctrl.page.data`数据进行一个深度合并之后渲染刷新。





